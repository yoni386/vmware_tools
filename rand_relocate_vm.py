# import argparse# import atexit# import csv# import getpass# import json# import multiprocessing# import logging# import os.path# import random# import re# import requestsimport subprocessimport sysfrom time import sleepfrom pyVim.connect import SmartConnect, Disconnectfrom pyVmomi import vim, vmodlfrom multiprocessing.dummy import Pool as ThreadPoolimport timefrom fnc2 import *import random__author__ = 'Yoni Shperling'def get_args():    """    Supports the command-line arguments listed below.    """    parser = argparse.ArgumentParser(        description="Randomly Svmotion each VM from a list one by one to a random host from a list, until stopped.")    parser.add_argument('-1', '--one-run',                        required=False,                        help='Stop after svmotioning each VM once',                        dest='onerun',                        action='store_true')    parser.add_argument('-d', '--debug',                        required=False,                        help='Enable debug output',                        dest='debug',                        action='store_true')    parser.add_argument('-H', '--host',                        nargs=1,                        required=True,                        help='The vCenter or ESXi host to connect to',                        dest='host',                        type=str)    parser.add_argument('-i', '--interval',                        nargs=1,                        required=False,                        help='Time to wait after a svmotion is finished to schedule a new one (default 30 sec) '                             'and log debug reresh',                        dest='interval',                        type=int,                        default=[30])    parser.add_argument('-l', '--log-file',                        nargs=1, required=False,                        help='File to log to (default = stdout)',                        dest='logfile',                        type=str)    parser.add_argument('-o', '--port',                        nargs=1,                        required=False,                        help='Server port to connect to (default = 443)',                        dest='port',                        type=int,                        default=[443])    parser.add_argument('-p', '--password',                        nargs=1,                        required=False,                        help='The password with which to connect to the host.',                        dest='password',                        type=str)    parser.add_argument('-S', '--disable-SSL-certificate-verification',                        required=False,                        help='Disable SSL certificate verification on connect',                        dest='nosslcheck',                        action='store_true')    parser.add_argument('-T', '--threads',                        nargs=1,                        required=False,                        help='Amount of simultanious svmotion to execute at once. (default = 3)',                        dest='threads',                        type=int,                        default=[3])    parser.add_argument('-u', '--user',                        nargs=1, required=True,                        help='The username with which to connect to the host',                        dest='username',                        type=str)    parser.add_argument('-v', '--verbose',                        required=False,                        help='Enable verbose output',                        dest='verbose',                        action='store_true')    parser.add_argument('-c', '--cluster',                        required=False,                        help='Cluster of The VM - not used - need to think on that',                        dest='cluster',                        type=str)    parser.add_argument('-F', '--fdatastore',                        required=False,                        help='Soruce datastore of The VM',                        dest='fdatastore',                        type=str)    parser.add_argument('-D', '--datastore',                        required=True,                        help='Datastore of The VM',                        dest='datastore',                        type=str)    parser.add_argument('-s', '--seed',                        required=False,                        help='Seed for VM and Host',                        dest='seed',                        type=int)    parser.add_argument('-n', '--number',                        required=False,                        help='Number of VM',                        dest='number',                        type=int)    parser.add_argument('-y', '--dry_run',                        required=False,                        help='Only simulate value is True',                        dest='dry_run',                        type=str)    parser.add_argument('-k', '--ds_type',                        required=False,                        help='ds type VMFS or NFS or vsan',                        dest='ds_type',                        nargs='+',                        type=str)    parser.add_argument('-G', '--ds_free_space',                        required=False,                        help='ds free space in GB',                        dest='ds_free_space',                        type=int)    parser.add_argument('-x', '--ds_to_exclude',                        required=False,                        help='ds to exclude to migrate to',                        dest='ds_to_exclude',                        nargs='+',                        type=str)    args = parser.parse_args()    return argsdef vm_svmotion_handler(si, logger, relocate_spec, vm, interval):    """    Will handle the thread handling to svmotion a virtual machine    """    logger.debug('THREAD %s - started' % vm.name)    migrate_priority = vim.VirtualMachine.MovePriority.defaultPriority    # Starting migration    # logger.debug('THREAD %s - Starting migration to datastore %s' % (vm.name, relocate_spec[3].name)) -> improve logs    start_time = time.time()    migrate_task = vm.RelocateVM_Task(spec=relocate_spec, priority='highPriority')    logger.debug('Migration %s took %s seconds' % (vm.name, time.time() - start_time))    logger.debug('Migration {} took {} seconds'.format(vm.name, time.time() - start_time))    run_loop = True    while run_loop:        info = migrate_task.info        logger.debug('THREAD %s - Checking svmotion task' % vm.name)        if info.state == vim.TaskInfo.State.success:            logger.debug('THREAD %s - svmotion finished' % vm.name)            run_loop = False            break        elif info.state == vim.TaskInfo.State.running:            logger.debug('THREAD %s - svmotion task is at %s percent' % (vm.name, info.progress))        elif info.state == vim.TaskInfo.State.queued:            logger.debug('THREAD %s - svmotion task is queued' % vm.name)        elif info.state == vim.TaskInfo.State.error:            if info.error.fault:                logger.info(                    'THREAD %s - svmotion task has quit with error: %s' % (vm.name, info.error.fault.faultMessage))            else:                logger.info('THREAD %s - svmotion task has quit with cancelation' % vm.name)            run_loop = False            break        logger.debug('THREAD {} - Sleeping second for new check'.format(vm.name))        sleep(1)    logger.debug(        'THREAD %s - Waiting %s seconds interval before ending the thread and releasing it for a new task' % (            vm.name, interval))    sleep(interval)def wait_for_pool_end(logger, pool, pool_results):    """    Waits for all running tasks to end.    """    logger.debug('Waiting for {} svmotions to complete'.format(len(pool_results)))    for result in pool_results:        result.wait()    pool.close()    pool.join()def main():    """    Clone a VM or template into multiple VMs with logical names with numbers and allow for post-processing    """    # Handling arguments    args = get_args()    onerun = args.onerun    debug = args.debug    host = args.host[0]    interval = args.interval[0]    log_file = args.logfile[0] if args.logfile else None    port = args.port[0]    password = args.password[0] if args.password else None    nosslcheck = args.nosslcheck    threads = args.threads[0]    username = args.username[0]    verbose = args.verbose    cluster = args.cluster    datastore = args.datastore    fdatastore = args.fdatastore    seed = args.seed    number = args.number    ds_type = args.ds_type if args.ds_type else ['VMFS', 'NFS']    dry_run = args.dry_run if args.dry_run else None    ds_free_space = args.ds_free_space if args.ds_free_space else 0    ds_to_exclude = ['mswg', 'mswg2', 'swgwork', 'vmgwork']    ds_to_exclude.extend(args.ds_to_exclude) if args.ds_to_exclude else None    # Logging settings    if debug:        log_level = logging.DEBUG    elif verbose:        log_level = logging.INFO    else:        log_level = logging.WARNING    if log_file:        logging.basicConfig(filename=log_file, format='%(asctime)s %(levelname)s %(message)s', level=log_level)    else:        logging.basicConfig(filename=log_file, format='%(asctime)s %(levelname)s %(message)s', level=log_level)    logger = logging.getLogger(__name__)    # Disabling SSL verification if set    if nosslcheck:        logger.debug('Disabling SSL certificate verification.')        requests.packages.urllib3.disable_warnings()        import ssl        if hasattr(ssl, '_create_unverified_context'):            ssl._create_default_https_context = ssl._create_unverified_context    # Getting user password    if password is None:        logger.debug('No command line password received, requesting password from user')        password = getpass.getpass(prompt='Enter password for vCenter %s for user %s: ' % (host, username))    start_time = time.time()    total_succ_results = []    pool_results = []    pool = ThreadPool(threads)    try:        si = vc_si(args)        logger.info('Building vm list, this may take some time.')        vms = VirtualMachine().get_all_vms_on_cluster(si, cluster)        logger.debug('Building vm list completed took %s seconds"' % (time.time() - start_time))        # vms = VirtualMachine().get_all_powered_on_vms(si, vms)        # vms = VirtualMachine().get_all_vms_on_datastore(si, fdatastore)        random.seed(seed) and logger.debug('Seed configured and the value is {}'.format(seed)) if seed else False        logger.debug('Datastore to exclude are {}'.format(ds_to_exclude))        logger.debug('Datastore type is {}'.format(ds_type)) if ds_type else None        random.shuffle(vms)        if number:            vms = random.sample(vms, number)            logger.debug('Number VM to svmotion is value is {}'.format(number))            logger.debug('VM to svmotion are {}'.format([vm.name for vm in vms]))        if len(vms) < threads:            logger.warning('Amount of threads %s can not be higher than'                           'amount of vms: Setting amount of threads to %s' % (threads, len(vms)))            threads = len(vms)        # Pool handling        logger.debug('Setting up pools and threads')        vm_index = 0        logger.debug('Pools created with %s threads' % threads)        run_loop = True        while run_loop:            # Check if a pool_result is finished            for result in pool_results:                if result.ready():                    logger.debug('Removing finished task from the pool results')                    total_succ_results.append(result)                    pool_results.remove(result)            # If the pool is still filled, continue            if len(pool_results) >= threads:                logger.debug('All threads running, not creating new svmotion tasks. Waiting 1 second to check again')                sleep(interval)                continue            vm = vms[vm_index]            try:                return_ds = Datastore().get_datastore_for_vm_relocate(si,                                                                      datastore,                                                                      ds_type,                                                                      ds_free_space,                                                                      ds_to_exclude,                                                                      vm)            except Exception:                logger.critical('DS is empty, exiting')                return 1            return_ds = random.choice(return_ds) if isinstance(return_ds, list) else return_ds            # print type(return_ds)            # if return_ds is list:            #     print True            #     return_ds = random.choice(return_ds)            #     return_ds = return_ds[0]            #            # else:            #     print False            #     return_ds = return_ds[0]            # return_ds = random.choice(return_ds)            # print return_ds.name            # return_ds = return_ds[0]            relocate_spec = vim.vm.RelocateSpec()            relocate_spec.datastore = return_ds            logger.info('Creating svmotion task for VM {} to datastore {}'.format(vm.name, return_ds.name))            logger.debug('VM {} is on esx {} migrating to datastore {}'.format(vm.name, vm.runtime.host.name,                                                                               return_ds.name))            logger.debug('Running in Dry Run mode') if dry_run else None            if not dry_run:                pool_results.append(pool.apply_async(vm_svmotion_handler, (si, logger, relocate_spec, vm, interval)))            vm_index += 1            if vm_index >= len(vms) and onerun:                logger.debug('One-run is enabled, all VMs are scheduled to svmotion. Finishing.')                wait_for_pool_end(logger, pool, pool_results)                run_loop = False                break            if vm_index >= len(vms):                logger.debug('Looping back to first VM')                vm_index = 0    except KeyboardInterrupt:        logger.info('Received interrupt, finishing running threads and not creating any new migrations')        if pool is not None and pool_results is not None:            wait_for_pool_end(logger, pool, pool_results)    except vmodl.MethodFault as err:        logger.critical('Caught vmodl fault: %s' % err.msg)        return 1    except Exception as err:        logger.critical('Caught exception: {}'.format(str(err)))        return 1    logger.info('Finished all tasks')    logger.debug('Total time took {} seconds'.format(time.time() - start_time))    logger.debug('Total tasks {}'.format(len(total_succ_results)))    return 0if __name__ == "__main__":    main()