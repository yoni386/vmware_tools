import subprocessimport sysfrom time import sleepfrom pyVim.connect import SmartConnect, Disconnectfrom pyVmomi import vim, vmodlfrom multiprocessing.dummy import Pool as ThreadPoolimport time# from fnc2 import *from common_helpers import *import random__author__ = 'Yoni Shperling'def get_args():    """    Supports the command-line arguments listed below.    """    parser = argparse.ArgumentParser(        description="Randomly Svmotion each VM from a list one by one to a random host from a list, until stopped.")    parser.add_argument('-1', '--one-run',                        required=False,                        help='Stop after svmotioning each VM once',                        dest='onerun',                        action='store_true')    parser.add_argument('-d', '--debug',                        required=False,                        help='Enable debug output',                        dest='debug',                        action='store_true')    parser.add_argument('-H', '--host',                        nargs=1,                        required=True,                        help='The vCenter or ESXi host to connect to',                        dest='host',                        type=str)    parser.add_argument('-i', '--interval',                        nargs=1,                        required=False,                        help='Time to wait after a svmotion is finished to schedule a new one (default 30 sec) '                             'and log debug reresh',                        dest='interval',                        type=int,                        default=[30])    parser.add_argument('-l', '--log-file',                        nargs=1, required=False,                        help='File to log to (default = stdout)',                        dest='logfile',                        type=str)    parser.add_argument('-o', '--port',                        nargs=1,                        required=False,                        help='Server port to connect to (default = 443)',                        dest='port',                        type=int,                        default=[443])    parser.add_argument('-p', '--password',                        nargs=1,                        required=False,                        help='The password with which to connect to the host.',                        dest='password',                        type=str)    parser.add_argument('-S', '--disable-SSL-certificate-verification',                        required=False,                        help='Disable SSL certificate verification on connect',                        dest='nosslcheck',                        action='store_true')    parser.add_argument('-T', '--threads',                        nargs=1,                        required=False,                        help='Amount of simultanious svmotion to execute at once. (default = 3)',                        dest='threads',                        type=int,                        default=[3])    parser.add_argument('-u', '--user',                        nargs=1, required=True,                        help='The username with which to connect to the host',                        dest='username',                        type=str)    parser.add_argument('-v', '--verbose',                        required=False,                        help='Enable verbose output',                        dest='verbose',                        action='store_true')    parser.add_argument('-c', '--cluster',                        required=False,                        help='Cluster of The VM - not used - need to think on that',                        dest='cluster',                        type=str)    parser.add_argument('-F', '--fdatastore',                        required=False,                        help='Source datastore of The VM',                        dest='fdatastore',                        type=str)    parser.add_argument('-D', '--datastore',                        required=True,                        help='Datastore of The VM',                        dest='datastore',                        type=str)    parser.add_argument('-s', '--seed',                        required=False,                        help='Seed for VM and Host',                        dest='seed',                        type=int)    parser.add_argument('-n', '--number',                        required=False,                        help='Number of VM',                        dest='number',                        type=int)    parser.add_argument('-y', '--dry_run',                        required=False,                        help='Only simulate value is True',                        dest='dry_run',                        type=str)    parser.add_argument('-k', '--ds_type',                        required=False,                        help='ds type VMFS or NFS or vsan',                        dest='ds_type',                        nargs='+',                        type=str)    parser.add_argument('-G', '--ds_free_space',                        required=False,                        help='ds free space in GB',                        dest='ds_free_space',                        type=int)    parser.add_argument('-x', '--ds_to_exclude',                        required=False,                        help='ds to exclude to migrate to',                        dest='ds_to_exclude',                        nargs='+',                        type=str)    args = parser.parse_args()    return argsdef vm_svmotion_handler(si, logger, relocate_spec, vm, interval):    """    Will handle the thread handling to svmotion a virtual machine    """    logger.debug('THREAD %s - started' % vm.name)    migrate_priority = vim.VirtualMachine.MovePriority.defaultPriority    # Starting migration    # logger.debug('THREAD %s - Starting migration to datastore %s' % (vm.name, relocate_spec[3].name)) -> improve logs    start_time = time.time()    migrate_task = vm.RelocateVM_Task(spec=relocate_spec, priority='highPriority')    logger.debug('Migration %s took %s seconds' % (vm.name, time.time() - start_time))    logger.debug('Migration {} took {} seconds'.format(vm.name, time.time() - start_time))    run_loop = True    while run_loop:        info = migrate_task.info        logger.debug('THREAD %s - Checking svmotion task' % vm.name)        if info.state == vim.TaskInfo.State.success:            logger.debug('THREAD %s - svmotion finished' % vm.name)            run_loop = False            break        elif info.state == vim.TaskInfo.State.running:            logger.debug('THREAD %s - svmotion task is at %s percent' % (vm.name, info.progress))        elif info.state == vim.TaskInfo.State.queued:            logger.debug('THREAD %s - svmotion task is queued' % vm.name)        elif info.state == vim.TaskInfo.State.error:            if info.error.fault:                logger.info(                    'THREAD %s - svmotion task has quit with error: %s' % (vm.name, info.error.fault.faultMessage))            else:                logger.info('THREAD %s - svmotion task has quit with cancelation' % vm.name)            run_loop = False            break        logger.debug('THREAD {} - Sleeping second for new check'.format(vm.name))        sleep(1)    logger.debug(        'THREAD %s - Waiting %s seconds interval before ending the thread and releasing it for a new task' % (            vm.name, interval))    sleep(interval)def wait_for_pool_end(logger, pool, pool_results):    """    Waits for all running tasks to end.    """    logger.debug('Waiting for {} svmotions to complete'.format(len(pool_results)))    for result in pool_results:        result.wait()    pool.close()    pool.join()def main():    """    Clone a VM or template into multiple VMs with logical names with numbers and allow for post-processing    """    # Handling arguments    args = get_args()    onerun = args.onerun    debug = args.debug    host = args.host[0]    interval = args.interval[0]    log_file = args.logfile[0] if args.logfile else None    port = args.port[0]    password = args.password[0] if args.password else None    nosslcheck = args.nosslcheck    threads = args.threads[0]    username = args.username[0]    verbose = args.verbose    cluster = args.cluster    datastore = args.datastore    fdatastore = args.fdatastore    seed = args.seed    number = args.number    ds_type = args.ds_type if args.ds_type else ['VMFS', 'NFS']    dry_run = args.dry_run if args.dry_run else None    ds_free_space = args.ds_free_space if args.ds_free_space else 0    ds_to_exclude = ['templates', 'template', 'mswg2', 'swgwork', 'vmgwork']    ds_to_exclude.extend(args.ds_to_exclude) if args.ds_to_exclude else None    # Logging settings    if debug:        log_level = logging.DEBUG    elif verbose:        log_level = logging.INFO    else:        log_level = logging.WARNING    if log_file:        logging.basicConfig(filename=log_file, format='%(asctime)s %(levelname)s %(message)s', level=log_level)    else:        logging.basicConfig(filename=log_file, format='%(asctime)s %(levelname)s %(message)s', level=log_level)    logger = logging.getLogger(__name__)    # Disabling SSL verification if set    if nosslcheck:        logger.debug('Disabling SSL certificate verification.')        requests.packages.urllib3.disable_warnings()        import ssl        if hasattr(ssl, '_create_unverified_context'):            ssl._create_default_https_context = ssl._create_unverified_context    # Getting user password    if password is None:        logger.debug('No command line password received, requesting password from user')        password = getpass.getpass(prompt='Enter password for vCenter %s for user %s: ' % (host, username))    start_time = time.time()    total_succ_results = []    pool_results = []    pool = ThreadPool(threads)    try:        si = vc_si(args)        logger.info('Building vm list, this may take some time.')        vms = []        vms = VirtualMachine().get_all_vms_on_cluster(si, cluster)        logger.debug('Building vm list completed took %s seconds"' % (time.time() - start_time))        # vms = VirtualMachine().get_all_powered_on_vms(si, vms)        # vms = VirtualMachine().get_all_vms_on_datastore(si, fdatastore)        random.seed(seed) and logger.debug('Seed configured and the value is {}'.format(seed)) if seed else False        logger.debug('Datastore to exclude are {}'.format(ds_to_exclude))        logger.debug('Datastore type is {}'.format(ds_type)) if ds_type else None        random.shuffle(vms)        if number:            vms = random.sample(vms, number)            logger.debug('Number VM to svmotion is value is {}'.format(number))            logger.debug('VM to svmotion are {}'.format([vm.name for vm in vms]))        if len(vms) < threads:            logger.warning('Amount of threads %s can not be higher than'                           'amount of vms: Setting amount of threads to %s' % (threads, len(vms)))            threads = len(vms)        # Pool handling        logger.debug('Setting up pools and threads')        vm_index = 0        logger.debug('Pools created with %s threads' % threads)        run_loop = True        while run_loop:            # Check if a pool_result is finished            for result in pool_results:                if result.ready():                    logger.debug('Removing finished task from the pool results')                    total_succ_results.append(result)                    pool_results.remove(result)            # If the pool is still filled, continue            if len(pool_results) >= threads:                logger.debug('All threads running, not creating new svmotion tasks. Waiting 1 second to check again')                sleep(interval)                continue            vm = vms[vm_index]            try:                return_ds = Datastore().get_datastore_for_vm_relocate(si,                                                                      datastore,                                                                      ds_type,                                                                      ds_free_space,                                                                      ds_to_exclude,                                                                      vm)            except Exception:                logger.critical('DS is empty, exiting')                return 1            return_ds = random.choice(return_ds) if isinstance(return_ds, list) else return_ds            relocate_spec = vim.vm.RelocateSpec()            relocate_spec.datastore = return_ds            logger.info('Creating svmotion task for VM {} to datastore {}'.format(vm.name, return_ds.name))            logger.debug('VM {} is on esx {} migrating to datastore {}'.format(vm.name, vm.runtime.host.name,                                                                               return_ds.name))            logger.debug('Running in Dry Run mode') if dry_run else None            if not dry_run:                pool_results.append(pool.apply_async(vm_svmotion_handler, (si, logger, relocate_spec, vm, interval)))            vm_index += 1            if vm_index >= len(vms) and onerun:                logger.debug('One-run is enabled, all VMs are scheduled to svmotion. Finishing.')                wait_for_pool_end(logger, pool, pool_results)                run_loop = False                break            if vm_index >= len(vms):                logger.debug('Looping back to first VM')                vm_index = 0    except KeyboardInterrupt:        logger.info('Received interrupt, finishing running threads and not creating any new migrations')        if pool is not None and pool_results is not None:            wait_for_pool_end(logger, pool, pool_results)    except vmodl.MethodFault as err:        logger.critical('Caught vmodl fault: %s' % err.msg)        return 1    except Exception as err:        logger.critical('Caught exception: {}'.format(str(err)))        return 1    logger.info('Finished all tasks')    logger.debug('Total time took {} seconds'.format(time.time() - start_time))    logger.debug('Total tasks {}'.format(len(total_succ_results)))    return 0if __name__ == "__main__":    main()